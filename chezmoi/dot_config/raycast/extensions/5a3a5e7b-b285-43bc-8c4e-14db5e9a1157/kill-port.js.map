{
  "version": 3,
  "sources": ["../src/kill-port.tsx"],
  "sourcesContent": ["import { showToast, Toast, LaunchProps, showHUD } from \"@raycast/api\";\nimport { exec } from \"child_process\";\nimport { promisify } from \"util\";\n\nconst execAsync = promisify(exec);\n\ninterface Arguments {\n  portNumber: string;\n}\n\ninterface PortProcess {\n  pid: string;\n  processName: string;\n  localAddress: string;\n}\n\n// Cache for process names with 10-second TTL for fast lookups\nconst processNameCache = new Map<string, { name: string; timestamp: number }>();\nconst CACHE_TTL = 10000; // 10 seconds\n\n// Pre-compiled regex patterns for maximum performance\nconst TCP_LISTENING_REGEX = /^TCP\\s+(\\S+)\\s+\\S+\\s+(LISTENING|ESCUCHANDO)\\s+(\\d+)$/;\nconst PROCESS_CSV_REGEX = /\"([^\"]+)\",\"(\\d+)\"/;\n\nexport default async function KillPort(props: LaunchProps<{ arguments: Arguments }>) {\n  const { portNumber } = props.arguments;\n\n  // Clean and validate port number\n  const cleanPort = portNumber.trim().replace(/[^0-9]/g, \"\");\n  const port = parseInt(cleanPort);\n\n  if (!cleanPort || isNaN(port) || port < 1 || port > 65535) {\n    await showToast({\n      style: Toast.Style.Failure,\n      title: \"Invalid Port Number\",\n      message: `\"${portNumber}\" is not a valid port. Use a number between 1-65535`,\n    });\n    return;\n  }\n\n  // Check for common system ports and warn\n  const systemPorts = [80, 443, 22, 21, 25, 53, 110, 993, 995, 135, 445];\n  if (systemPorts.includes(port)) {\n    await showToast({\n      style: Toast.Style.Failure,\n      title: \"System Port Warning\",\n      message: `Port ${port} is a system/service port. Operation cancelled for safety.`,\n    });\n    return;\n  }\n\n  // Show loading toast with instant feedback\n  const loadingToast = await showToast({\n    style: Toast.Style.Animated,\n    title: \"\u26A1 Searching...\",\n    message: `Looking for process on port ${port}`,\n  });\n\n  try {\n    // Find process using the port with robust error handling\n    const portProcess = await findProcessUsingPortRobust(port);\n\n    if (!portProcess) {\n      loadingToast.hide();\n      await showHUD(`\u2705 Port ${port} is already free`);\n      return;\n    }\n\n    // Update toast to show terminating\n    loadingToast.title = \"\uD83D\uDCA5 Terminating...\";\n    loadingToast.message = `Killing process in port ${port} (PID: ${portProcess.pid})`;\n\n    // Kill the process\n    const success = await killProcessOptimized(portProcess.pid);\n\n    loadingToast.hide();\n\n    if (success) {\n      // Success - show HUD for quick feedback\n      await showHUD(`\uD83D\uDE80 Port ${port} freed! Process terminated`);\n    } else {\n      await showToast({\n        style: Toast.Style.Failure,\n        title: \"\u274C Failed to Kill Process\",\n        message: `Could not terminate process in port ${port}. Try running as administrator.`,\n      });\n    }\n  } catch (error) {\n    loadingToast.hide();\n    await showToast({\n      style: Toast.Style.Failure,\n      title: \"Error\",\n      message: error instanceof Error ? error.message : \"An unexpected error occurred\",\n    });\n  }\n}\n\nasync function findProcessUsingPortRobust(port: number): Promise<PortProcess | null> {\n  try {\n    // First check cache for recent data\n    const cachedResult = getCachedPortProcess(port);\n    if (cachedResult) {\n      return cachedResult;\n    }\n\n    // Try primary method with netstat\n    let netstatOutput = \"\";\n    let processOutput = \"\";\n\n    try {\n      // Execute both commands with better error handling\n      const [netstatResult, tasklistResult] = await Promise.allSettled([\n        execAsync(`netstat -ano -p tcp`, {\n          timeout: 8000,\n          maxBuffer: 2 * 1024 * 1024,\n          windowsHide: true,\n        }),\n        execAsync(`tasklist /fo csv /nh`, {\n          timeout: 8000,\n          maxBuffer: 2 * 1024 * 1024,\n          windowsHide: true,\n        }),\n      ]);\n\n      if (netstatResult.status === \"fulfilled\") {\n        netstatOutput = netstatResult.value.stdout;\n      }\n\n      if (tasklistResult.status === \"fulfilled\") {\n        processOutput = tasklistResult.value.stdout;\n      }\n    } catch (error) {\n      console.error(\"Command execution error:\", error);\n    }\n\n    // If primary netstat failed, try alternative approach\n    if (!netstatOutput) {\n      try {\n        const alternativeResult = await execAsync(`netstat -ano | findstr :${port}`, {\n          timeout: 5000,\n          maxBuffer: 1024 * 1024,\n          windowsHide: true,\n        });\n        netstatOutput = alternativeResult.stdout;\n      } catch {\n        throw new Error(`Failed to find process using port ${port}. Try running as administrator.`);\n      }\n    }\n\n    if (!netstatOutput || netstatOutput.trim().length === 0) {\n      return null;\n    }\n\n    // Build process name mapping\n    const processMap = new Map<string, string>();\n    if (processOutput) {\n      const now = Date.now();\n      const processLines = processOutput.split(\"\\n\");\n\n      for (const line of processLines) {\n        if (line.trim()) {\n          const match = PROCESS_CSV_REGEX.exec(line);\n          if (match) {\n            const [, processName, pid] = match;\n            processMap.set(pid, processName);\n            // Update cache with fresh data\n            processNameCache.set(pid, { name: processName, timestamp: now });\n          }\n        }\n      }\n    }\n\n    // Parse netstat output to find our target port\n    const lines = netstatOutput.split(\"\\n\");\n\n    for (const line of lines) {\n      const trimmedLine = line.trim();\n      if (!trimmedLine) continue;\n\n      // Skip header lines\n      if (\n        trimmedLine.includes(\"Proto\") ||\n        trimmedLine.includes(\"Conexiones\") ||\n        trimmedLine.includes(\"activas\") ||\n        trimmedLine.includes(\"Direcci\u00F3n\")\n      ) {\n        continue;\n      }\n\n      // Try regex parsing first\n      const match = TCP_LISTENING_REGEX.exec(trimmedLine);\n      let localAddress = \"\";\n      let pid = \"\";\n\n      if (match) {\n        localAddress = match[1];\n        pid = match[3];\n      } else {\n        // Fallback to manual parsing\n        const parts = trimmedLine.split(/\\s+/);\n        if (parts.length >= 5 && parts[0] === \"TCP\") {\n          const addr = parts[1];\n          const state = parts[3];\n          const processId = parts[4];\n\n          if ((state === \"LISTENING\" || state === \"ESCUCHANDO\") && addr.endsWith(`:${port}`) && processId !== \"0\") {\n            localAddress = addr;\n            pid = processId;\n          }\n        }\n      }\n\n      // Check if this matches our target port\n      if (localAddress.endsWith(`:${port}`) && pid !== \"0\") {\n        // Get process name from our cache/map\n        let processName = processMap.get(pid) || getCachedProcessName(pid) || \"Unknown Process\";\n\n        // If we still don't have a name, try a quick direct lookup\n        if (processName === \"Unknown Process\") {\n          try {\n            const { stdout } = await execAsync(`tasklist /fo csv /nh /fi \"PID eq ${pid}\"`, {\n              timeout: 3000,\n              windowsHide: true,\n            });\n            const directMatch = stdout.match(/\"([^\"]+)\"/);\n            if (directMatch) {\n              processName = directMatch[1];\n              // Cache this for future use\n              processNameCache.set(pid, { name: processName, timestamp: Date.now() });\n            }\n          } catch {\n            // Ignore errors, keep \"Unknown Process\"\n          }\n        }\n\n        const portProcess = {\n          pid,\n          processName,\n          localAddress,\n        };\n\n        // Cache this result for future quick lookups\n        cachePortProcess(port, portProcess);\n\n        return portProcess;\n      }\n    }\n\n    return null;\n  } catch (error) {\n    console.error(\"Port search error:\", error);\n    throw new Error(\n      `Port search failed: ${error instanceof Error ? error.message : \"Network command execution failed\"}`,\n    );\n  }\n}\n\nfunction getCachedProcessName(pid: string): string | null {\n  const cached = processNameCache.get(pid);\n  if (cached && Date.now() - cached.timestamp < CACHE_TTL) {\n    return cached.name;\n  }\n  return null;\n}\n\nasync function killProcessOptimized(pid: string): Promise<boolean> {\n  try {\n    // Try graceful termination first, then force kill if needed\n    try {\n      await execAsync(`taskkill /PID ${pid}`, {\n        timeout: 3000,\n        windowsHide: true,\n      });\n    } catch {\n      // If graceful fails, try force kill\n      await execAsync(`taskkill /PID ${pid} /F`, {\n        timeout: 3000,\n        windowsHide: true,\n      });\n    }\n    // Clear cache entry for this PID\n    processNameCache.delete(pid);\n    return true;\n  } catch (error) {\n    console.error(\"Kill process failed:\", error);\n    return false;\n  }\n}\n\n// Cache for port-to-process mapping with 5-second TTL\nconst portProcessCache = new Map<number, { process: PortProcess; timestamp: number }>();\nconst PORT_CACHE_TTL = 5000; // 5 seconds\n\nfunction getCachedPortProcess(port: number): PortProcess | null {\n  const cached = portProcessCache.get(port);\n  if (cached && Date.now() - cached.timestamp < PORT_CACHE_TTL) {\n    return cached.process;\n  }\n  portProcessCache.delete(port);\n  return null;\n}\n\nfunction cachePortProcess(port: number, process: PortProcess): void {\n  portProcessCache.set(port, { process, timestamp: Date.now() });\n}\n\n// Clean up expired cache entries periodically\nif (typeof setInterval !== \"undefined\") {\n  setInterval(() => {\n    const now = Date.now();\n    // Clean process name cache\n    for (const [pid, entry] of processNameCache.entries()) {\n      if (now - entry.timestamp >= CACHE_TTL) {\n        processNameCache.delete(pid);\n      }\n    }\n    // Clean port process cache\n    for (const [port, entry] of portProcessCache.entries()) {\n      if (now - entry.timestamp >= PORT_CACHE_TTL) {\n        portProcessCache.delete(port);\n      }\n    }\n  }, CACHE_TTL / 2); // Clean more frequently\n}\n"],
  "mappings": "yaAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,aAAAE,IAAA,eAAAC,EAAAH,GAAA,IAAAI,EAAuD,wBACvDC,EAAqB,yBACrBC,EAA0B,gBAEpBC,KAAY,aAAU,MAAI,EAa1BC,EAAmB,IAAI,IACvBC,EAAY,IAGZC,EAAsB,uDACtBC,EAAoB,oBAE1B,eAAOT,EAAgCU,EAA8C,CACnF,GAAM,CAAE,WAAAC,CAAW,EAAID,EAAM,UAGvBE,EAAYD,EAAW,KAAK,EAAE,QAAQ,UAAW,EAAE,EACnDE,EAAO,SAASD,CAAS,EAE/B,GAAI,CAACA,GAAa,MAAMC,CAAI,GAAKA,EAAO,GAAKA,EAAO,MAAO,CACzD,QAAM,aAAU,CACd,MAAO,QAAM,MAAM,QACnB,MAAO,sBACP,QAAS,IAAIF,CAAU,qDACzB,CAAC,EACD,MACF,CAIA,GADoB,CAAC,GAAI,IAAK,GAAI,GAAI,GAAI,GAAI,IAAK,IAAK,IAAK,IAAK,GAAG,EACrD,SAASE,CAAI,EAAG,CAC9B,QAAM,aAAU,CACd,MAAO,QAAM,MAAM,QACnB,MAAO,sBACP,QAAS,QAAQA,CAAI,4DACvB,CAAC,EACD,MACF,CAGA,IAAMC,EAAe,QAAM,aAAU,CACnC,MAAO,QAAM,MAAM,SACnB,MAAO,sBACP,QAAS,+BAA+BD,CAAI,EAC9C,CAAC,EAED,GAAI,CAEF,IAAME,EAAc,MAAMC,EAA2BH,CAAI,EAEzD,GAAI,CAACE,EAAa,CAChBD,EAAa,KAAK,EAClB,QAAM,WAAQ,eAAUD,CAAI,kBAAkB,EAC9C,MACF,CAGAC,EAAa,MAAQ,2BACrBA,EAAa,QAAU,2BAA2BD,CAAI,UAAUE,EAAY,GAAG,IAG/E,IAAME,EAAU,MAAMC,EAAqBH,EAAY,GAAG,EAE1DD,EAAa,KAAK,EAEdG,EAEF,QAAM,WAAQ,kBAAWJ,CAAI,4BAA4B,EAEzD,QAAM,aAAU,CACd,MAAO,QAAM,MAAM,QACnB,MAAO,gCACP,QAAS,uCAAuCA,CAAI,iCACtD,CAAC,CAEL,OAASM,EAAO,CACdL,EAAa,KAAK,EAClB,QAAM,aAAU,CACd,MAAO,QAAM,MAAM,QACnB,MAAO,QACP,QAASK,aAAiB,MAAQA,EAAM,QAAU,8BACpD,CAAC,CACH,CACF,CAEA,eAAeH,EAA2BH,EAA2C,CACnF,GAAI,CAEF,IAAMO,EAAeC,EAAqBR,CAAI,EAC9C,GAAIO,EACF,OAAOA,EAIT,IAAIE,EAAgB,GAChBC,EAAgB,GAEpB,GAAI,CAEF,GAAM,CAACC,EAAeC,CAAc,EAAI,MAAM,QAAQ,WAAW,CAC/DpB,EAAU,sBAAuB,CAC/B,QAAS,IACT,UAAW,QACX,YAAa,EACf,CAAC,EACDA,EAAU,uBAAwB,CAChC,QAAS,IACT,UAAW,QACX,YAAa,EACf,CAAC,CACH,CAAC,EAEGmB,EAAc,SAAW,cAC3BF,EAAgBE,EAAc,MAAM,QAGlCC,EAAe,SAAW,cAC5BF,EAAgBE,EAAe,MAAM,OAEzC,OAASN,EAAO,CACd,QAAQ,MAAM,2BAA4BA,CAAK,CACjD,CAGA,GAAI,CAACG,EACH,GAAI,CAMFA,GAL0B,MAAMjB,EAAU,2BAA2BQ,CAAI,GAAI,CAC3E,QAAS,IACT,UAAW,QACX,YAAa,EACf,CAAC,GACiC,MACpC,MAAQ,CACN,MAAM,IAAI,MAAM,qCAAqCA,CAAI,iCAAiC,CAC5F,CAGF,GAAI,CAACS,GAAiBA,EAAc,KAAK,EAAE,SAAW,EACpD,OAAO,KAIT,IAAMI,EAAa,IAAI,IACvB,GAAIH,EAAe,CACjB,IAAMI,EAAM,KAAK,IAAI,EACfC,EAAeL,EAAc,MAAM;AAAA,CAAI,EAE7C,QAAWM,KAAQD,EACjB,GAAIC,EAAK,KAAK,EAAG,CACf,IAAMC,EAAQrB,EAAkB,KAAKoB,CAAI,EACzC,GAAIC,EAAO,CACT,GAAM,CAAC,CAAEC,EAAaC,CAAG,EAAIF,EAC7BJ,EAAW,IAAIM,EAAKD,CAAW,EAE/BzB,EAAiB,IAAI0B,EAAK,CAAE,KAAMD,EAAa,UAAWJ,CAAI,CAAC,CACjE,CACF,CAEJ,CAGA,IAAMM,EAAQX,EAAc,MAAM;AAAA,CAAI,EAEtC,QAAWO,KAAQI,EAAO,CACxB,IAAMC,EAAcL,EAAK,KAAK,EAI9B,GAHI,CAACK,GAIHA,EAAY,SAAS,OAAO,GAC5BA,EAAY,SAAS,YAAY,GACjCA,EAAY,SAAS,SAAS,GAC9BA,EAAY,SAAS,cAAW,EAEhC,SAIF,IAAMJ,EAAQtB,EAAoB,KAAK0B,CAAW,EAC9CC,EAAe,GACfH,EAAM,GAEV,GAAIF,EACFK,EAAeL,EAAM,CAAC,EACtBE,EAAMF,EAAM,CAAC,MACR,CAEL,IAAMM,EAAQF,EAAY,MAAM,KAAK,EACrC,GAAIE,EAAM,QAAU,GAAKA,EAAM,CAAC,IAAM,MAAO,CAC3C,IAAMC,EAAOD,EAAM,CAAC,EACdE,EAAQF,EAAM,CAAC,EACfG,EAAYH,EAAM,CAAC,GAEpBE,IAAU,aAAeA,IAAU,eAAiBD,EAAK,SAAS,IAAIxB,CAAI,EAAE,GAAK0B,IAAc,MAClGJ,EAAeE,EACfL,EAAMO,EAEV,CACF,CAGA,GAAIJ,EAAa,SAAS,IAAItB,CAAI,EAAE,GAAKmB,IAAQ,IAAK,CAEpD,IAAID,EAAcL,EAAW,IAAIM,CAAG,GAAKQ,EAAqBR,CAAG,GAAK,kBAGtE,GAAID,IAAgB,kBAClB,GAAI,CACF,GAAM,CAAE,OAAAU,CAAO,EAAI,MAAMpC,EAAU,oCAAoC2B,CAAG,IAAK,CAC7E,QAAS,IACT,YAAa,EACf,CAAC,EACKU,EAAcD,EAAO,MAAM,WAAW,EACxCC,IACFX,EAAcW,EAAY,CAAC,EAE3BpC,EAAiB,IAAI0B,EAAK,CAAE,KAAMD,EAAa,UAAW,KAAK,IAAI,CAAE,CAAC,EAE1E,MAAQ,CAER,CAGF,IAAMhB,EAAc,CAClB,IAAAiB,EACA,YAAAD,EACA,aAAAI,CACF,EAGA,OAAAQ,EAAiB9B,EAAME,CAAW,EAE3BA,CACT,CACF,CAEA,OAAO,IACT,OAASI,EAAO,CACd,cAAQ,MAAM,qBAAsBA,CAAK,EACnC,IAAI,MACR,uBAAuBA,aAAiB,MAAQA,EAAM,QAAU,kCAAkC,EACpG,CACF,CACF,CAEA,SAASqB,EAAqBR,EAA4B,CACxD,IAAMY,EAAStC,EAAiB,IAAI0B,CAAG,EACvC,OAAIY,GAAU,KAAK,IAAI,EAAIA,EAAO,UAAYrC,EACrCqC,EAAO,KAET,IACT,CAEA,eAAe1B,EAAqBc,EAA+B,CACjE,GAAI,CAEF,GAAI,CACF,MAAM3B,EAAU,iBAAiB2B,CAAG,GAAI,CACtC,QAAS,IACT,YAAa,EACf,CAAC,CACH,MAAQ,CAEN,MAAM3B,EAAU,iBAAiB2B,CAAG,MAAO,CACzC,QAAS,IACT,YAAa,EACf,CAAC,CACH,CAEA,OAAA1B,EAAiB,OAAO0B,CAAG,EACpB,EACT,OAASb,EAAO,CACd,eAAQ,MAAM,uBAAwBA,CAAK,EACpC,EACT,CACF,CAGA,IAAM0B,EAAmB,IAAI,IACvBC,EAAiB,IAEvB,SAASzB,EAAqBR,EAAkC,CAC9D,IAAM+B,EAASC,EAAiB,IAAIhC,CAAI,EACxC,OAAI+B,GAAU,KAAK,IAAI,EAAIA,EAAO,UAAYE,EACrCF,EAAO,SAEhBC,EAAiB,OAAOhC,CAAI,EACrB,KACT,CAEA,SAAS8B,EAAiB9B,EAAckC,EAA4B,CAClEF,EAAiB,IAAIhC,EAAM,CAAE,QAAAkC,EAAS,UAAW,KAAK,IAAI,CAAE,CAAC,CAC/D,CAGI,OAAO,YAAgB,KACzB,YAAY,IAAM,CAChB,IAAMpB,EAAM,KAAK,IAAI,EAErB,OAAW,CAACK,EAAKgB,CAAK,IAAK1C,EAAiB,QAAQ,EAC9CqB,EAAMqB,EAAM,WAAazC,GAC3BD,EAAiB,OAAO0B,CAAG,EAI/B,OAAW,CAACnB,EAAMmC,CAAK,IAAKH,EAAiB,QAAQ,EAC/ClB,EAAMqB,EAAM,WAAaF,GAC3BD,EAAiB,OAAOhC,CAAI,CAGlC,EAAGN,EAAY,CAAC",
  "names": ["kill_port_exports", "__export", "KillPort", "__toCommonJS", "import_api", "import_child_process", "import_util", "execAsync", "processNameCache", "CACHE_TTL", "TCP_LISTENING_REGEX", "PROCESS_CSV_REGEX", "props", "portNumber", "cleanPort", "port", "loadingToast", "portProcess", "findProcessUsingPortRobust", "success", "killProcessOptimized", "error", "cachedResult", "getCachedPortProcess", "netstatOutput", "processOutput", "netstatResult", "tasklistResult", "processMap", "now", "processLines", "line", "match", "processName", "pid", "lines", "trimmedLine", "localAddress", "parts", "addr", "state", "processId", "getCachedProcessName", "stdout", "directMatch", "cachePortProcess", "cached", "portProcessCache", "PORT_CACHE_TTL", "process", "entry"]
}
