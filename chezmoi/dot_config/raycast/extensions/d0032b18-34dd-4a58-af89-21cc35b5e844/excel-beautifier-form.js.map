{
  "version": 3,
  "sources": ["../src/excel-beautifier-form.tsx", "../src/parser/formula-types.ts", "../src/parser/types.ts", "../src/parser/parser.ts", "../src/parser/raw-text-formatter.ts", "../src/parser/excel-formula-parser.ts"],
  "sourcesContent": ["import { Form, ActionPanel, Action, showToast, Toast } from \"@raycast/api\";\nimport { useState, useCallback, useEffect } from \"react\";\nimport { ExcelFormulaBeautifier } from \"./parser/excel-formula-parser\";\n\nexport default function Command() {\n  const [formula, setFormula] = useState<string>(\"\");\n  const [beautifiedFormula, setBeautifiedFormula] = useState<string>(\"\");\n\n  const beautifyFormula = useCallback((inputFormula: string) => {\n    if (!inputFormula.trim()) {\n      setBeautifiedFormula(\"\");\n      return;\n    }\n\n    try {\n      // Ensure formula starts with =\n      const formulaWithEquals = inputFormula.trim().startsWith(\"=\") ? inputFormula.trim() : \"=\" + inputFormula.trim();\n\n      // Use our custom formatter with the enhanced parser\n      const beautified = ExcelFormulaBeautifier.rawText(formulaWithEquals);\n\n      setBeautifiedFormula(beautified);\n      showToast({\n        style: Toast.Style.Success,\n        title: \"Formula beautified\",\n      });\n    } catch (formulaError) {\n      setBeautifiedFormula(\"\");\n      showToast({\n        style: Toast.Style.Failure,\n        title: \"Invalid Excel formula\",\n        message: formulaError instanceof Error ? formulaError.message : String(formulaError),\n      });\n    }\n  }, []);\n\n  // Debounce the beautification to avoid too many calls while typing\n  useEffect(() => {\n    const timeoutId = setTimeout(() => {\n      beautifyFormula(formula);\n    }, 300); // 300ms delay\n\n    return () => clearTimeout(timeoutId);\n  }, [formula, beautifyFormula]);\n\n  const handleFormulaChange = (value: string) => {\n    setFormula(value);\n  };\n\n  const handleClear = () => {\n    setFormula(\"\");\n    setBeautifiedFormula(\"\");\n  };\n\n  const getResultPreview = () => {\n    return beautifiedFormula;\n  };\n\n  return (\n    <Form\n      actions={\n        <ActionPanel>\n          <Action title=\"Clear\" onAction={handleClear} shortcut={{ modifiers: [\"cmd\"], key: \"l\" }} />\n          {beautifiedFormula && (\n            <Action.CopyToClipboard\n              title=\"Copy Beautified Formula\"\n              content={beautifiedFormula}\n              shortcut={{ modifiers: [\"cmd\"], key: \"c\" }}\n            />\n          )}\n          {formula && (\n            <Action.CopyToClipboard\n              title=\"Copy Original Formula\"\n              content={formula.trim().startsWith(\"=\") ? formula.trim() : \"=\" + formula.trim()}\n              shortcut={{ modifiers: [\"cmd\", \"shift\"], key: \"c\" }}\n            />\n          )}\n        </ActionPanel>\n      }\n    >\n      <Form.TextArea\n        id=\"formula\"\n        title=\"Excel Formula\"\n        placeholder=\"Enter your Excel formula here (e.g., =SUM(A1:B10)+IF(C1>0,D1*2,IF(C1>0,D1*2,0))\"\n        value={formula}\n        onChange={handleFormulaChange}\n        info=\"Type your formula and see the beautified result below\"\n      />\n\n      <Form.Separator />\n\n      {beautifiedFormula && (\n        <Form.TextArea\n          id=\"beautified\"\n          title=\"Beautified Result\"\n          value={getResultPreview()}\n          onChange={() => {}} // Make it read-only\n        />\n      )}\n    </Form>\n  );\n}\n", "// Excel Formula Types Enumeration\n\nexport enum FormulaTypes {\n  // Logical functions (English)\n  IF = \"IF\",\n  IFS = \"IFS\",\n  AND = \"AND\",\n  OR = \"OR\",\n  NOT = \"NOT\",\n  IFERROR = \"IFERROR\",\n  IFNA = \"IFNA\",\n  ISERROR = \"ISERROR\",\n  ISNA = \"ISNA\",\n  ISBLANK = \"ISBLANK\",\n  ISNUMBER = \"ISNUMBER\",\n  ISTEXT = \"ISTEXT\",\n\n  // Logical functions (French)\n  SI = \"SI\",\n  SIS = \"SIS\",\n  ET = \"ET\",\n  OU = \"OU\",\n  NON = \"NON\",\n  SIERREUR = \"SIERREUR\",\n  SINA = \"SINA\",\n  ESTERREUR = \"ESTERREUR\",\n  ESTNA = \"ESTNA\",\n  ESTVIDE = \"ESTVIDE\",\n  ESTNUM = \"ESTNUM\",\n  ESTTEXTE = \"ESTTEXTE\",\n\n  // Math and statistical functions (English)\n  SUM = \"SUM\",\n  SUMIF = \"SUMIF\",\n  SUMIFS = \"SUMIFS\",\n  SUMPRODUCT = \"SUMPRODUCT\",\n  AVERAGE = \"AVERAGE\",\n  AVERAGEIF = \"AVERAGEIF\",\n  AVERAGEIFS = \"AVERAGEIFS\",\n  COUNT = \"COUNT\",\n  COUNTA = \"COUNTA\",\n  COUNTBLANK = \"COUNTBLANK\",\n  COUNTIF = \"COUNTIF\",\n  COUNTIFS = \"COUNTIFS\",\n  MAX = \"MAX\",\n  MAXA = \"MAXA\",\n  MIN = \"MIN\",\n  MINA = \"MINA\",\n  MEDIAN = \"MEDIAN\",\n  MODE = \"MODE\",\n  STDEV = \"STDEV\",\n  VAR = \"VAR\",\n\n  // Math and statistical functions (French)\n  SOMME = \"SOMME\",\n  SOMME_SI = \"SOMME.SI\",\n  SOMME_SI_ENS = \"SOMME.SI.ENS\",\n  SOMMEPROD = \"SOMMEPROD\",\n  MOYENNE = \"MOYENNE\",\n  MOYENNE_SI = \"MOYENNE.SI\",\n  MOYENNE_SI_ENS = \"MOYENNE.SI.ENS\",\n  NB = \"NB\",\n  NBVAL = \"NBVAL\",\n  NB_VIDE = \"NB.VIDE\",\n  NB_SI = \"NB.SI\",\n  NB_SI_ENS = \"NB.SI.ENS\",\n  MEDIANE = \"MEDIANE\",\n  ECARTYPE = \"ECARTYPE\",\n\n  // Math functions (English)\n  ROUND = \"ROUND\",\n  ROUNDUP = \"ROUNDUP\",\n  ROUNDDOWN = \"ROUNDDOWN\",\n  CEILING = \"CEILING\",\n  FLOOR = \"FLOOR\",\n  TRUNC = \"TRUNC\",\n  INT = \"INT\",\n  ABS = \"ABS\",\n  SQRT = \"SQRT\",\n  POWER = \"POWER\",\n  EXP = \"EXP\",\n  LN = \"LN\",\n  LOG = \"LOG\",\n  LOG10 = \"LOG10\",\n  MOD = \"MOD\",\n  RAND = \"RAND\",\n  RANDBETWEEN = \"RANDBETWEEN\",\n\n  // Math functions (French)\n  ARRONDI = \"ARRONDI\",\n  ARRONDI_SUP = \"ARRONDI.SUP\",\n  ARRONDI_INF = \"ARRONDI.INF\",\n  PLAFOND = \"PLAFOND\",\n  PLANCHER = \"PLANCHER\",\n  TRONQUE = \"TRONQUE\",\n  ENT = \"ENT\",\n  RACINE = \"RACINE\",\n  PUISSANCE = \"PUISSANCE\",\n  ALEA = \"ALEA\",\n  ALEA_ENTRE_BORNES = \"ALEA.ENTRE.BORNES\",\n\n  // Lookup and reference functions (English)\n  VLOOKUP = \"VLOOKUP\",\n  HLOOKUP = \"HLOOKUP\",\n  XLOOKUP = \"XLOOKUP\",\n  LOOKUP = \"LOOKUP\",\n  INDEX = \"INDEX\",\n  MATCH = \"MATCH\",\n  CHOOSE = \"CHOOSE\",\n  INDIRECT = \"INDIRECT\",\n  OFFSET = \"OFFSET\",\n  ROW = \"ROW\",\n  COLUMN = \"COLUMN\",\n  ROWS = \"ROWS\",\n  COLUMNS = \"COLUMNS\",\n\n  // Lookup and reference functions (French)\n  RECHERCHEV = \"RECHERCHEV\",\n  RECHERCHEH = \"RECHERCHEH\",\n  RECHERCHEX = \"RECHERCHEX\",\n  RECHERCHE = \"RECHERCHE\",\n  EQUIV = \"EQUIV\",\n  CHOISIR = \"CHOISIR\",\n  DECALER = \"DECALER\",\n  LIGNE = \"LIGNE\",\n  COLONNE = \"COLONNE\",\n  LIGNES = \"LIGNES\",\n  COLONNES = \"COLONNES\",\n\n  // Text functions (English)\n  CONCATENATE = \"CONCATENATE\",\n  CONCAT = \"CONCAT\",\n  TEXTJOIN = \"TEXTJOIN\",\n  LEFT = \"LEFT\",\n  RIGHT = \"RIGHT\",\n  MID = \"MID\",\n  LEN = \"LEN\",\n  FIND = \"FIND\",\n  SEARCH = \"SEARCH\",\n  SUBSTITUTE = \"SUBSTITUTE\",\n  REPLACE = \"REPLACE\",\n  UPPER = \"UPPER\",\n  LOWER = \"LOWER\",\n  PROPER = \"PROPER\",\n  TRIM = \"TRIM\",\n  CLEAN = \"CLEAN\",\n  VALUE = \"VALUE\",\n  TEXT = \"TEXT\",\n  CHAR = \"CHAR\",\n  CODE = \"CODE\",\n  EXACT = \"EXACT\",\n\n  // Text functions (French)\n  CONCATENER = \"CONCATENER\",\n  JOINDRE_TEXTE = \"JOINDRE.TEXTE\",\n  GAUCHE = \"GAUCHE\",\n  DROITE = \"DROITE\",\n  STXT = \"STXT\",\n  NBCAR = \"NBCAR\",\n  CHERCHE = \"CHERCHE\",\n  TROUVE = \"TROUVE\",\n  SUBSTITUE = \"SUBSTITUE\",\n  REMPLACER = \"REMPLACER\",\n  MAJUSCULE = \"MAJUSCULE\",\n  MINUSCULE = \"MINUSCULE\",\n  NOMPROPRE = \"NOMPROPRE\",\n  SUPPRESPACE = \"SUPPRESPACE\",\n  EPURAGE = \"EPURAGE\",\n  CNUM = \"CNUM\",\n  TEXTE = \"TEXTE\",\n  CAR = \"CAR\",\n\n  // Date and time functions (English)\n  TODAY = \"TODAY\",\n  NOW = \"NOW\",\n  DATE = \"DATE\",\n  TIME = \"TIME\",\n  YEAR = \"YEAR\",\n  MONTH = \"MONTH\",\n  DAY = \"DAY\",\n  HOUR = \"HOUR\",\n  MINUTE = \"MINUTE\",\n  SECOND = \"SECOND\",\n  WEEKDAY = \"WEEKDAY\",\n  WEEKNUM = \"WEEKNUM\",\n  WORKDAY = \"WORKDAY\",\n  NETWORKDAYS = \"NETWORKDAYS\",\n  EDATE = \"EDATE\",\n  EOMONTH = \"EOMONTH\",\n  DATEDIF = \"DATEDIF\",\n  DATEVALUE = \"DATEVALUE\",\n  TIMEVALUE = \"TIMEVALUE\",\n\n  // Date and time functions (French)\n  AUJOURDHUI = \"AUJOURDHUI\",\n  MAINTENANT = \"MAINTENANT\",\n  TEMPS = \"TEMPS\",\n  ANNEE = \"ANNEE\",\n  MOIS = \"MOIS\",\n  JOUR = \"JOUR\",\n  HEURE = \"HEURE\",\n  SECONDE = \"SECONDE\",\n  JOURSEM = \"JOURSEM\",\n  NO_SEMAINE = \"NO.SEMAINE\",\n  SERIE_JOUR_OUVRE = \"SERIE.JOUR.OUVRE\",\n  NB_JOURS_OUVRES = \"NB.JOURS.OUVRES\",\n  MOIS_DECALER = \"MOIS.DECALER\",\n  FIN_MOIS = \"FIN.MOIS\",\n  DATEVAL = \"DATEVAL\",\n  TEMPSVAL = \"TEMPSVAL\",\n\n  // Financial functions (English)\n  PMT = \"PMT\",\n  PV = \"PV\",\n  FV = \"FV\",\n  RATE = \"RATE\",\n  NPER = \"NPER\",\n  NPV = \"NPV\",\n  IRR = \"IRR\",\n  XIRR = \"XIRR\",\n  XNPV = \"XNPV\",\n\n  // Financial functions (French)\n  VPM = \"VPM\",\n  VA = \"VA\",\n  VC = \"VC\",\n  TAUX = \"TAUX\",\n  NPM = \"NPM\",\n  VAN = \"VAN\",\n  TRI = \"TRI\",\n  TRID = \"TRID\",\n  VAND = \"VAND\",\n\n  // Database functions (English)\n  DSUM = \"DSUM\",\n  DAVERAGE = \"DAVERAGE\",\n  DCOUNT = \"DCOUNT\",\n  DCOUNTA = \"DCOUNTA\",\n  DMAX = \"DMAX\",\n  DMIN = \"DMIN\",\n\n  // Database functions (French)\n  BDSOMME = \"BDSOMME\",\n  BDMOYENNE = \"BDMOYENNE\",\n  BDNB = \"BDNB\",\n  BDNBVAL = \"BDNBVAL\",\n  BDMAX = \"BDMAX\",\n  BDMIN = \"BDMIN\",\n\n  // Engineering functions (English)\n  CONVERT = \"CONVERT\",\n\n  // Array functions (newer Excel - English)\n  FILTER = \"FILTER\",\n  SORT = \"SORT\",\n  SORTBY = \"SORTBY\",\n  UNIQUE = \"UNIQUE\",\n  SEQUENCE = \"SEQUENCE\",\n  TRANSPOSE = \"TRANSPOSE\",\n\n  // Array functions (newer Excel - French)\n  FILTRE = \"FILTRE\",\n  TRIER = \"TRIER\",\n  TRIER_PAR = \"TRIER.PAR\",\n\n  // Exotic/Advanced functions (English)\n  LAMBDA = \"LAMBDA\",\n  LET = \"LET\",\n  MAKEARRAY = \"MAKEARRAY\",\n  MAP = \"MAP\",\n  REDUCE = \"REDUCE\",\n  SCAN = \"SCAN\",\n  RANDARRAY = \"RANDARRAY\",\n  SWITCH = \"SWITCH\",\n  AGGREGATE = \"AGGREGATE\",\n  SUBTOTAL = \"SUBTOTAL\",\n  FORECAST = \"FORECAST\",\n  TREND = \"TREND\",\n  LINEST = \"LINEST\",\n  LOGEST = \"LOGEST\",\n  GROWTH = \"GROWTH\",\n  PERCENTILE = \"PERCENTILE\",\n  QUARTILE = \"QUARTILE\",\n  RANK = \"RANK\",\n  PERCENTRANK = \"PERCENTRANK\",\n  SKEW = \"SKEW\",\n  KURT = \"KURT\",\n  COVAR = \"COVAR\",\n  CORREL = \"CORREL\",\n  RSQ = \"RSQ\",\n  INTERCEPT = \"INTERCEPT\",\n  SLOPE = \"SLOPE\",\n  STANDARDIZE = \"STANDARDIZE\",\n  PROB = \"PROB\",\n  POISSON = \"POISSON\",\n  BINOMIAL = \"BINOMIAL\",\n  COMBIN = \"COMBIN\",\n  PERMUT = \"PERMUT\",\n  BETA = \"BETA\",\n  GAMMA = \"GAMMA\",\n  WEIBULL = \"WEIBULL\",\n  LOGNORM = \"LOGNORM\",\n  HYPGEOM = \"HYPGEOM\",\n  NORMINV = \"NORMINV\",\n  NORMSDIST = \"NORMSDIST\",\n  NORMSINV = \"NORMSINV\",\n  TDIST = \"TDIST\",\n  TINV = \"TINV\",\n  FDIST = \"FDIST\",\n  FINV = \"FINV\",\n  CHITEST = \"CHITEST\",\n  CHIINV = \"CHIINV\",\n  ZTEST = \"ZTEST\",\n  TTEST = \"TTEST\",\n  T_TEST = \"T.TEST\",\n  FTEST = \"FTEST\",\n  F_TEST = \"F.TEST\",\n  CHI_TEST = \"CHI.TEST\",\n  ZTEST_ALT = \"Z.TEST\",\n  GEOMEAN = \"GEOMEAN\",\n  HARMEAN = \"HARMEAN\",\n  TRIMMEAN = \"TRIMMEAN\",\n  SMALL = \"SMALL\",\n  LARGE = \"LARGE\",\n  COUNTUNIQUE = \"COUNTUNIQUE\",\n  BYROW = \"BYROW\",\n  BYCOL = \"BYCOL\",\n  CONFIDENCE = \"CONFIDENCE\",\n  DEVSQ = \"DEVSQ\",\n  AVEDEV = \"AVEDEV\",\n  STDEVP = \"STDEVP\",\n  STDEVS = \"STDEVS\",\n  VARP = \"VARP\",\n  VARS = \"VARS\",\n  AVERAGEA = \"AVERAGEA\",\n  PRODUCT = \"PRODUCT\",\n  SUMSQ = \"SUMSQ\",\n  SUMX2MY2 = \"SUMX2MY2\",\n  SUMX2PY2 = \"SUMX2PY2\",\n  SUMXMY2 = \"SUMXMY2\",\n  MINVERSE = \"MINVERSE\",\n  MMULT = \"MMULT\",\n  MDETERM = \"MDETERM\",\n\n  // Exotic/Advanced functions (French)\n  CREER_MATRICE = \"CREER.MATRICE\",\n  APPLIQUER = \"APPLIQUER\",\n  REDUIRE = \"REDUIRE\",\n  ANALYSER = \"ANALYSER\",\n  CREER_ALEA_MATRICE = \"CREER.ALEA.MATRICE\",\n  BASCULER = \"BASCULER\",\n  SOUS_TOTAL = \"SOUS.TOTAL\",\n  PREVISION = \"PREVISION\",\n  TENDANCE = \"TENDANCE\",\n  DROITEREG = \"DROITEREG\",\n  LOGREG = \"LOGREG\",\n  CROISSANCE = \"CROISSANCE\",\n  RANG = \"RANG\",\n  PERCENTRANG = \"PERCENTRANG\",\n  CORRELATION = \"CORRELATION\",\n  COEFFICIENT_R2 = \"COEFFICIENT.R2\",\n  ORDONNEE_ORIGINE = \"ORDONNEE.ORIGINE\",\n  PENTE = \"PENTE\",\n  CENTRER_REDUIRE = \"CENTRER.REDUIRE\",\n  PROBABILITE = \"PROBABILITE\",\n  BINOM_DIST = \"BINOM.DIST\",\n  PERMUTATION = \"PERMUTATION\",\n  LOI_NORMALE_INVERSE = \"LOI.NORMALE.INVERSE\",\n  LOI_NORMALE_STANDARD = \"LOI.NORMALE.STANDARD\",\n  LOI_NORMALE_STANDARD_INVERSE = \"LOI.NORMALE.STANDARD.INVERSE\",\n  LOI_T = \"LOI.T\",\n  INVERSE_LOI_T = \"INVERSE.LOI.T\",\n  LOI_F = \"LOI.F\",\n  INVERSE_LOI_F = \"INVERSE.LOI.F\",\n  TEST_KHIDEUX = \"TEST.KHIDEUX\",\n  INVERSE_LOI_KHIDEUX = \"INVERSE.LOI.KHIDEUX\",\n  TEST_Z = \"TEST.Z\",\n  TEST_T = \"TEST.T\",\n  TEST_F = \"TEST.F\",\n  MOYENNE_GEOMETRIQUE = \"MOYENNE.GEOMETRIQUE\",\n  MOYENNE_HARMONIQUE = \"MOYENNE.HARMONIQUE\",\n  MOYENNE_TRIMMEE = \"MOYENNE.TRIMMEE\",\n  PETIT = \"PETIT\",\n  GRAND = \"GRAND\",\n  NBVAL_UNIQUE = \"NBVAL.UNIQUE\",\n  PAR_LIGNE = \"PAR.LIGNE\",\n  PAR_COLONNE = \"PAR.COLONNE\",\n  INTERVALLE_CONFIANCE = \"INTERVALLE.CONFIANCE\",\n  SOMME_CARRES_ECARTS = \"SOMME.CARRES.ECARTS\",\n  MOYENNE_ECARTS = \"MOYENNE.ECARTS\",\n  ECARTYPE_POP = \"ECARTYPE.POP\",\n  ECARTYPE_ECHE = \"ECARTYPE.ECHE\",\n  VAR_POP = \"VAR.POP\",\n  VAR_ECHE = \"VAR.ECHE\",\n  MOYENNEA = \"MOYENNEA\",\n  PRODUIT = \"PRODUIT\",\n  SOMME_CARRES = \"SOMME.CARRES\",\n  SOMME_DIFF_CARRES = \"SOMME.DIFF.CARRES\",\n  SOMME_SOMME_CARRES = \"SOMME.SOMME.CARRES\",\n  SOMME_DIFF_CARRES_Y = \"SOMME.DIFF.CARRES.Y\",\n  INVERSE_MATRICE = \"INVERSE.MATRICE\",\n  PRODUIT_MATRICE = \"PRODUIT.MATRICE\",\n  DETERMINANT_MATRICE = \"DETERMINANT.MATRICE\",\n}\n", "// Core types and interfaces for Excel Formula Parser\n\nimport { FormulaTypes } from \"./formula-types\";\n\nexport class ExcelExpression {\n  readonly original: string;\n  private childs: Array<ExcelExpression> = [];\n\n  constructor(original: string) {\n    this.original = original;\n  }\n\n  addChild(child: ExcelExpression): void {\n    this.childs.push(child);\n  }\n\n  getChilds(): Array<ExcelExpression> {\n    return this.childs;\n  }\n}\n\nexport class SubExpression extends ExcelExpression {}\n\nexport class FormulaExpr extends ExcelExpression {\n  readonly formula: FormulaTypes;\n\n  constructor(original: string, formula: FormulaTypes) {\n    super(original);\n    this.formula = formula;\n  }\n}\n\nexport class SimpleExpression extends ExcelExpression {}\n\nexport class OperatorExpression extends ExcelExpression {\n  readonly operator: string;\n\n  constructor(operator: string) {\n    super(operator);\n    this.operator = operator;\n  }\n}\n\nexport class CellReferenceExpression extends ExcelExpression {\n  readonly sheet?: string; // Sheet name (e.g., \"Sheet1\" in \"Sheet1!A1\")\n  readonly column: string; // Column letter(s) (e.g., \"A\", \"AB\")\n  readonly row: string; // Row number (e.g., \"1\", \"100\")\n  readonly isColumnAbsolute: boolean; // True if column has $ (e.g., \"$A1\")\n  readonly isRowAbsolute: boolean; // True if row has $ (e.g., \"A$1\")\n\n  constructor(\n    original: string,\n    sheet: string | undefined,\n    column: string,\n    row: string,\n    isColumnAbsolute: boolean,\n    isRowAbsolute: boolean,\n  ) {\n    super(original);\n    this.sheet = sheet;\n    this.column = column;\n    this.row = row;\n    this.isColumnAbsolute = isColumnAbsolute;\n    this.isRowAbsolute = isRowAbsolute;\n  }\n\n  getFullReference(): string {\n    const sheetPrefix = this.sheet ? `${this.sheet}!` : \"\";\n    const colPrefix = this.isColumnAbsolute ? \"$\" : \"\";\n    const rowPrefix = this.isRowAbsolute ? \"$\" : \"\";\n    return `${sheetPrefix}${colPrefix}${this.column}${rowPrefix}${this.row}`;\n  }\n}\n\nexport class CellRangeExpression extends ExcelExpression {\n  readonly sheet?: string; // Sheet name if specified\n  readonly startCell: CellReferenceExpression;\n  readonly endCell: CellReferenceExpression;\n\n  constructor(\n    original: string,\n    sheet: string | undefined,\n    startCell: CellReferenceExpression,\n    endCell: CellReferenceExpression,\n  ) {\n    super(original);\n    this.sheet = sheet;\n    this.startCell = startCell;\n    this.endCell = endCell;\n  }\n\n  getFullReference(): string {\n    const sheetPrefix = this.sheet ? `${this.sheet}!` : \"\";\n    return `${sheetPrefix}${this.startCell.getFullReference().replace(/^.*!/, \"\")}:${this.endCell.getFullReference().replace(/^.*!/, \"\")}`;\n  }\n}\n\nexport interface FormattingOptions {\n  useNestingIndicators?: boolean;\n  useOperatorSpacing?: boolean;\n  indentSize?: number;\n  maxInlineLength?: number;\n  maxInlineParams?: number;\n}\n\nexport const DEFAULT_FORMATTING_OPTIONS: FormattingOptions = {\n  useNestingIndicators: true,\n  useOperatorSpacing: true,\n  indentSize: 4,\n  maxInlineLength: 40,\n  maxInlineParams: 3,\n};\n", "// Excel Formula Parser - Pure parsing logic\n\nimport { FormulaTypes } from \"./formula-types\";\nimport {\n  ExcelExpression,\n  SubExpression,\n  FormulaExpr,\n  OperatorExpression,\n  CellReferenceExpression,\n  CellRangeExpression,\n} from \"./types\";\n\nexport class ExcelFormulaParser {\n  private static readonly formulaTypes: Array<string> = Object.values(FormulaTypes);\n  private static readonly formulaTypesMap: Record<string, FormulaTypes> = {\n    ...Object.entries(FormulaTypes).reduce(\n      (acc, [, value]) => {\n        acc[value] = value as FormulaTypes;\n        return acc;\n      },\n      {} as Record<string, FormulaTypes>,\n    ),\n  };\n\n  // Define operators in order of precedence (longest first to avoid partial matches)\n  private static readonly operators: Array<string> = [\n    \"<=\",\n    \">=\",\n    \"<>\",\n    \"!=\",\n    \"==\",\n    \"+\",\n    \"-\",\n    \"*\",\n    \"/\",\n    \"^\",\n    \"&\",\n    \"=\",\n    \"<\",\n    \">\",\n  ];\n\n  private static findOperatorAt(input: string, position: number): string | null {\n    // Check for 2-character operators first\n    if (position < input.length - 1) {\n      const twoChar = input.substring(position, position + 2);\n      if (this.operators.includes(twoChar)) {\n        return twoChar;\n      }\n    }\n\n    // Check for single-character operators\n    const oneChar = input.charAt(position);\n    if (this.operators.includes(oneChar)) {\n      return oneChar;\n    }\n\n    return null;\n  }\n\n  private static parseCellReference(text: string): CellReferenceExpression | CellRangeExpression | null {\n    // Remove any leading/trailing whitespace\n    text = text.trim();\n\n    // Check for range (contains :)\n    if (text.includes(\":\")) {\n      return this.parseCellRange(text);\n    }\n\n    // Parse single cell reference\n    return this.parseSingleCellReference(text);\n  }\n\n  private static parseCellRange(text: string): CellRangeExpression | null {\n    // Split on colon\n    const parts = text.split(\":\");\n    if (parts.length !== 2) {\n      return null;\n    }\n\n    const [startPart, endPart] = parts;\n    let sheet: string | undefined;\n    let start = startPart;\n    const end = endPart;\n\n    // Check if sheet is specified in the start part\n    if (start.includes(\"!\")) {\n      const sheetSplit = start.split(\"!\");\n      sheet = sheetSplit[0].replace(/^'|'$/g, \"\"); // Remove quotes\n      start = sheetSplit[1];\n    }\n\n    // Parse start and end cells\n    const startCell = this.parseSingleCellReference(start);\n    const endCell = this.parseSingleCellReference(end);\n\n    if (!startCell || !endCell) {\n      return null;\n    }\n\n    return new CellRangeExpression(text, sheet, startCell, endCell);\n  }\n\n  private static parseSingleCellReference(text: string): CellReferenceExpression | null {\n    // Pattern for cell reference: [Sheet!][$]Column[$]Row\n    // Examples: A1, $A1, A$1, $A$1, Sheet1!A1, 'Sheet Name'!$A$1\n    const cellPattern = /^(?:([^!]+)!)?(\\$?)([A-Z]+)(\\$?)(\\d+)$/i;\n    const match = text.match(cellPattern);\n\n    if (!match) {\n      return null;\n    }\n\n    const [, sheet, colAbsolute, column, rowAbsolute, row] = match;\n\n    // Clean sheet name (remove quotes if present)\n    const cleanSheet = sheet ? sheet.replace(/^'|'$/g, \"\") : undefined;\n\n    return new CellReferenceExpression(\n      text,\n      cleanSheet,\n      column.toUpperCase(),\n      row,\n      colAbsolute === \"$\",\n      rowAbsolute === \"$\",\n    );\n  }\n\n  private static parseExpressions(\n    parent: ExcelExpression,\n    startIndex: number,\n    input: string,\n    separator: string,\n  ): number {\n    let token = \"\";\n    let i: number = startIndex;\n    let inDoubleQuote = false;\n\n    while (i < input.length) {\n      const char = input[i];\n      const prevChar = i > 0 ? input[i - 1] : \"\";\n\n      // Handle quotes\n      if (char === '\"' && prevChar !== \"\\\\\") {\n        inDoubleQuote = !inDoubleQuote;\n        token += char;\n        i++;\n        continue;\n      }\n\n      // Skip operator/special char detection inside quotes\n      if (inDoubleQuote) {\n        token += char;\n        i++;\n        continue;\n      }\n\n      const operator = this.findOperatorAt(input, i);\n\n      if (char === \"(\") {\n        if (token.trim().length > 0) {\n          // Check if token is a function name\n          const upperToken = token.trim().toUpperCase();\n          if (this.formulaTypes.includes(upperToken)) {\n            const formulaType = this.formulaTypesMap[upperToken];\n            if (formulaType) {\n              i = this.parseFormula(parent, formulaType, i, input, separator);\n              token = \"\";\n            }\n          } else {\n            // Regular token before parentheses\n            const cellRef = this.parseCellReference(token.trim());\n            if (cellRef) {\n              parent.addChild(cellRef);\n            } else {\n              parent.addChild(new ExcelExpression(token.trim()));\n            }\n            token = \"\";\n            const expression = new SubExpression(\"\");\n            parent.addChild(expression);\n            i = this.parseExpressions(expression, i + 1, input, separator);\n          }\n        } else {\n          // Parentheses without preceding token\n          const expression = new SubExpression(\"\");\n          parent.addChild(expression);\n          i = this.parseExpressions(expression, i + 1, input, separator);\n        }\n      } else if (char === \")\") {\n        if (token.trim().length > 0) {\n          const cellRef = this.parseCellReference(token.trim());\n          if (cellRef) {\n            parent.addChild(cellRef);\n          } else {\n            parent.addChild(new ExcelExpression(token.trim()));\n          }\n        }\n        return i;\n      } else if (operator) {\n        // Found an operator\n        if (token.trim().length > 0) {\n          const cellRef = this.parseCellReference(token.trim());\n          if (cellRef) {\n            parent.addChild(cellRef);\n          } else {\n            parent.addChild(new ExcelExpression(token.trim()));\n          }\n          token = \"\";\n        }\n        parent.addChild(new OperatorExpression(operator));\n        i += operator.length - 1; // Skip the operator characters (-1 because i++ will happen)\n      } else if (char === \" \" || char === \"\\t\" || char === \"\\n\") {\n        token += char;\n      } else {\n        token += char;\n      }\n\n      i++;\n    }\n\n    if (token.trim().length > 0) {\n      const cellRef = this.parseCellReference(token.trim());\n      if (cellRef) {\n        parent.addChild(cellRef);\n      } else {\n        parent.addChild(new ExcelExpression(token.trim()));\n      }\n    }\n\n    return i;\n  }\n\n  private static parseFormula(\n    parent: ExcelExpression,\n    formula: FormulaTypes,\n    startIndex: number,\n    input: string,\n    separator: string,\n  ): number {\n    const formulaExpr = new FormulaExpr(\"\", formula);\n    parent.addChild(formulaExpr);\n\n    let i = this.parserAdvanceTo(\"(\", startIndex, input);\n    let token = \"\";\n    let braceCount = 0;\n\n    while (i < input.length) {\n      if (input[i] === separator && braceCount === 0) {\n        if (token.trim().length > 0) {\n          const paramExpression = new ExcelExpression(token.trim());\n          this.parseExpressions(paramExpression, 0, token, separator);\n\n          if (paramExpression.getChilds().length === 1) {\n            formulaExpr.addChild(paramExpression.getChilds()[0]);\n          } else if (paramExpression.getChilds().length > 1) {\n            formulaExpr.addChild(paramExpression);\n          } else {\n            // No children found, try to parse as cell reference or add as simple expression\n            const cellRef = this.parseCellReference(token.trim());\n            if (cellRef) {\n              formulaExpr.addChild(cellRef);\n            } else {\n              formulaExpr.addChild(new ExcelExpression(token.trim()));\n            }\n          }\n        }\n        token = \"\";\n      } else {\n        if (input[i] === \"(\") {\n          braceCount++;\n        } else if (input[i] === \")\") {\n          braceCount--;\n        }\n\n        if (braceCount < 0) {\n          // End of function parameters\n          if (token.trim().length > 0) {\n            const paramExpression = new ExcelExpression(token.trim());\n            this.parseExpressions(paramExpression, 0, token, separator);\n\n            if (paramExpression.getChilds().length === 1) {\n              formulaExpr.addChild(paramExpression.getChilds()[0]);\n            } else if (paramExpression.getChilds().length > 1) {\n              formulaExpr.addChild(paramExpression);\n            } else {\n              // No children found, try to parse as cell reference or add as simple expression\n              const cellRef = this.parseCellReference(token.trim());\n              if (cellRef) {\n                formulaExpr.addChild(cellRef);\n              } else {\n                formulaExpr.addChild(new ExcelExpression(token.trim()));\n              }\n            }\n          }\n          return i;\n        }\n\n        token += input[i];\n      }\n      i++;\n    }\n\n    // If we reach here, the function was not properly closed\n    throw new Error(`Function ${formula} is missing closing parenthesis`);\n  }\n\n  private static parserAdvanceTo(char: string, startIndex: number, input: string): number {\n    let i = startIndex;\n    while (i < input.length && input[i] !== char) {\n      i++;\n    }\n    return i + 1; // Move past the found character\n  }\n\n  private static validateFormula(formula: string): void {\n    // Check for balanced parentheses\n    let parenCount = 0;\n    let inSingleQuote = false;\n    let inDoubleQuote = false;\n\n    for (let i = 0; i < formula.length; i++) {\n      const char = formula[i];\n      const prevChar = i > 0 ? formula[i - 1] : \"\";\n\n      // Handle quotes (ignore escaped quotes)\n      if (char === \"'\" && prevChar !== \"\\\\\") {\n        inSingleQuote = !inSingleQuote;\n        continue;\n      }\n      if (char === '\"' && prevChar !== \"\\\\\") {\n        inDoubleQuote = !inDoubleQuote;\n        continue;\n      }\n\n      // Skip parentheses inside quotes\n      if (inSingleQuote || inDoubleQuote) {\n        continue;\n      }\n\n      if (char === \"(\") {\n        parenCount++;\n      } else if (char === \")\") {\n        parenCount--;\n        if (parenCount < 0) {\n          throw new Error(\"Unexpected closing parenthesis ')'\");\n        }\n      }\n    }\n\n    // Check for unclosed quotes\n    if (inSingleQuote) {\n      throw new Error(\"Unclosed single quote in formula\");\n    }\n    if (inDoubleQuote) {\n      throw new Error(\"Unclosed double quote in formula\");\n    }\n\n    // Check for unmatched parentheses\n    if (parenCount > 0) {\n      throw new Error(`Missing ${parenCount} closing parenthesis${parenCount > 1 ? \"es\" : \"\"} ')'`);\n    }\n\n    // Check for trailing operators\n    const trimmed = formula.trim();\n    if (trimmed.length > 0) {\n      const lastChar = trimmed[trimmed.length - 1];\n      if ([\"+\", \"-\", \"*\", \"/\", \"=\", \"<\", \">\", \"&\"].includes(lastChar)) {\n        throw new Error(`Formula cannot end with operator '${lastChar}'`);\n      }\n    }\n\n    // Check for empty parentheses in functions\n    const emptyParenPattern = /[A-Z][A-Z0-9_]*\\(\\s*\\)/gi;\n    if (emptyParenPattern.test(formula)) {\n      const match = formula.match(/([A-Z][A-Z0-9_]*)\\(\\s*\\)/gi);\n      if (match) {\n        throw new Error(`Function ${match[0].replace(\"()\", \"\")} has empty parentheses`);\n      }\n    }\n  }\n\n  static parse(formula: string): ExcelExpression {\n    // Remove leading = if present\n    let cleanFormula = formula.trim();\n    if (cleanFormula.startsWith(\"=\")) {\n      cleanFormula = cleanFormula.substring(1);\n    }\n\n    // Validate formula syntax before parsing\n    this.validateFormula(cleanFormula);\n\n    // Determine separator (European uses ; US uses ,)\n    const separator = cleanFormula.includes(\";\") ? \";\" : \",\";\n\n    try {\n      const baseExpression = new ExcelExpression(cleanFormula);\n      this.parseExpressions(baseExpression, 0, cleanFormula, separator);\n\n      return baseExpression;\n    } catch (error) {\n      // Re-throw validation errors with better messages\n      if (error instanceof Error) {\n        throw new Error(error.message);\n      }\n      throw new Error(\"Invalid formula syntax\");\n    }\n  }\n}\n", "// Excel Formula Formatter - Pure text formatting logic\n\nimport {\n  ExcelExpression,\n  SubExpression,\n  FormulaExpr,\n  OperatorExpression,\n  CellReferenceExpression,\n  CellRangeExpression,\n  FormattingOptions,\n  DEFAULT_FORMATTING_OPTIONS,\n} from \"./types\";\n\nexport class ExcelRawTextFormatter {\n  private options: FormattingOptions;\n\n  constructor(options: Partial<FormattingOptions> = {}) {\n    this.options = { ...DEFAULT_FORMATTING_OPTIONS, ...options };\n  }\n\n  format(expression: ExcelExpression, hasEqualsSign: boolean = false): string {\n    const result = this.prettyPrint(expression, 0);\n    return (hasEqualsSign ? \"=\" : \"\") + result;\n  }\n\n  private prettyPrint(expression: ExcelExpression, depth: number): string {\n    const children = expression.getChilds();\n\n    // If no children, return the original content\n    if (children.length === 0) {\n      return expression.original || \"\";\n    }\n\n    let result = \"\";\n\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n\n      if (child instanceof FormulaExpr) {\n        result += this.formatFunction(child, depth);\n      } else if (child instanceof SubExpression) {\n        result += this.formatSubExpression(child, depth);\n      } else if (child instanceof OperatorExpression) {\n        result += this.formatOperator(child, i, children);\n      } else if (child instanceof CellReferenceExpression) {\n        result += this.formatCellReference(child);\n      } else if (child instanceof CellRangeExpression) {\n        result += this.formatCellRange(child);\n      } else {\n        // For regular expressions, check if they have children or use original\n        if (child.getChilds().length === 0) {\n          result += child.original || \"\";\n        } else {\n          result += this.prettyPrint(child, depth);\n        }\n      }\n    }\n\n    return result;\n  }\n\n  private formatFunction(func: FormulaExpr, depth: number): string {\n    const params = func.getChilds();\n    if (params.length === 0) {\n      return func.formula + \"()\";\n    }\n\n    // Check if this function should be formatted inline\n    if (this.shouldFormatInline(func)) {\n      let result = func.formula + \"(\";\n      for (let i = 0; i < params.length; i++) {\n        const param = params[i];\n        const isLast = i === params.length - 1;\n\n        if (param instanceof FormulaExpr && this.shouldFormatInline(param)) {\n          result += this.formatFunction(param, depth + 1);\n        } else if (param instanceof SubExpression) {\n          result += this.formatSubExpression(param, depth);\n        } else {\n          const paramContent = param.getChilds().length === 0 ? param.original || \"\" : this.prettyPrint(param, depth);\n          result += paramContent || \"\";\n        }\n\n        if (!isLast) {\n          result += \"; \";\n        }\n      }\n      result += \")\";\n      return result;\n    }\n\n    // Multi-line formatting for complex functions\n    let result = func.formula + \"(\\n\";\n\n    for (let i = 0; i < params.length; i++) {\n      const param = params[i];\n      const isLast = i === params.length - 1;\n\n      // Add indentation and nesting indicator for parameters\n      result += this.indent(depth + 1);\n      if (this.options.useNestingIndicators) {\n        result += this.getNestingIndicator(depth + 1, isLast);\n      }\n\n      if (param instanceof FormulaExpr) {\n        // For nested functions, don't add extra indicator since formatFunction will handle it\n        const functionResult = this.formatFunction(param, depth + 1);\n        result += functionResult;\n      } else if (param instanceof SubExpression) {\n        const subResult = this.formatSubExpression(param, depth + 1);\n        result += subResult;\n      } else {\n        // For parameter content, preserve original or format children\n        const paramContent = param.getChilds().length === 0 ? param.original || \"\" : this.prettyPrint(param, depth + 1);\n        result += paramContent || \"\";\n      }\n\n      if (!isLast) {\n        result += \";\";\n        result += \"\\n\";\n      } else {\n        // Last parameter - add closing paren on same line\n        result += \")\";\n      }\n    }\n\n    return result;\n  }\n\n  private shouldFormatInline(func: FormulaExpr): boolean {\n    const params = func.getChilds();\n\n    // No parameters or only one parameter\n    if (params.length === 0 || params.length === 1) {\n      // Check if the single parameter is simple\n      if (params.length === 1) {\n        const param = params[0];\n        // If it's a nested function, don't inline\n        if (param instanceof FormulaExpr) {\n          return false;\n        }\n        // If it's a complex sub-expression, don't inline\n        if (param instanceof SubExpression && this.containsFunction(param)) {\n          return false;\n        }\n        // Check the content length\n        const content = param.original || this.prettyPrint(param, 0);\n        return content.length <= 30;\n      }\n      return true;\n    }\n\n    // Multiple parameters - only inline if all are very simple and short\n    if (params.length <= (this.options.maxInlineParams || 3)) {\n      let totalLength = 0;\n      for (const param of params) {\n        if (param instanceof FormulaExpr || (param instanceof SubExpression && this.containsFunction(param))) {\n          return false;\n        }\n        const content = param.original || this.prettyPrint(param, 0);\n        totalLength += content.length;\n        if (totalLength > (this.options.maxInlineLength || 40)) {\n          return false;\n        }\n      }\n      return totalLength <= (this.options.maxInlineLength || 40);\n    }\n\n    return false;\n  }\n\n  private formatSubExpression(subExpr: SubExpression, depth: number): string {\n    const content = this.prettyPrint(subExpr, depth);\n\n    // If it's simple, keep on one line\n    if (!content.includes(\"\\n\") && content.length < 50 && !this.containsFunction(subExpr)) {\n      return \"(\" + content + \")\";\n    }\n\n    // Complex sub-expression gets multi-line formatting\n    return \"(\\n\" + this.indent(depth + 1) + content + \"\\n\" + this.indent(depth) + \")\";\n  }\n\n  private formatOperator(operator: OperatorExpression, index: number, siblings: ExcelExpression[]): string {\n    if (!this.options.useOperatorSpacing) {\n      return operator.operator;\n    }\n\n    const op = operator.operator;\n    let result = \"\";\n\n    // Add space before operator (except for certain cases)\n    const prevSibling = index > 0 ? siblings[index - 1] : null;\n    const nextSibling = index + 1 < siblings.length ? siblings[index + 1] : null;\n\n    const shouldSpaceBefore = this.shouldSpaceBeforeOperator(op, prevSibling);\n    const shouldSpaceAfter = this.shouldSpaceAfterOperator(op);\n\n    if (shouldSpaceBefore) {\n      result += \" \";\n    }\n\n    result += op;\n\n    if (shouldSpaceAfter) {\n      result += \" \";\n    }\n\n    // If next sibling is a multi-line function, add line break (no extra indent, formatFunction handles it)\n    if (nextSibling instanceof FormulaExpr && !this.shouldFormatInline(nextSibling)) {\n      result += \"\\n\";\n    }\n\n    return result;\n  }\n\n  private shouldSpaceBeforeOperator(operator: string, prevSibling: ExcelExpression | null): boolean {\n    // Don't space before minus if it's at start or likely a negative number\n    if (operator === \"-\") {\n      if (!prevSibling) return false; // Beginning of expression\n      if (prevSibling instanceof OperatorExpression) {\n        const prevOp = prevSibling.operator;\n        // After another operator, likely unary minus\n        if ([\"+\", \"-\", \"*\", \"/\", \"^\", \"=\", \"<\", \">\", \"<=\", \">=\", \"<>\", \"!=\", \"==\", \"(\"].includes(prevOp)) {\n          return false;\n        }\n      }\n    }\n\n    // Don't space around colon in ranges (A1:B10)\n    if (operator === \":\") {\n      return false;\n    }\n\n    return true;\n  }\n\n  private shouldSpaceAfterOperator(operator: string): boolean {\n    // Don't space around colon in ranges (A1:B10)\n    if (operator === \":\") {\n      return false;\n    }\n\n    return true;\n  }\n\n  private formatCellReference(cellRef: CellReferenceExpression): string {\n    // Use the built-in method to get properly formatted reference\n    return cellRef.getFullReference();\n  }\n\n  private formatCellRange(cellRange: CellRangeExpression): string {\n    // Use the built-in method to get properly formatted range\n    return cellRange.getFullReference();\n  }\n\n  private containsFunction(expr: ExcelExpression): boolean {\n    if (expr instanceof FormulaExpr) {\n      return true;\n    }\n    return expr.getChilds().some((child) => this.containsFunction(child));\n  }\n\n  private needsSpacing(current: ExcelExpression, next: ExcelExpression): boolean {\n    if (current instanceof FormulaExpr || next instanceof FormulaExpr) {\n      return false; // Functions handle their own spacing\n    }\n\n    if (current instanceof OperatorExpression || next instanceof OperatorExpression) {\n      return false; // Operators handle their own spacing\n    }\n\n    return false; // Let operators handle all spacing needs\n  }\n\n  private indent(depth: number): string {\n    const indentChar = \" \".repeat(this.options.indentSize || 4);\n    return indentChar.repeat(depth);\n  }\n\n  private getNestingIndicator(depth: number, isLast: boolean = false): string {\n    if (depth === 0) return \"\";\n\n    // Create a simple but consistent nesting indicator\n    const prefix = \"  \".repeat(Math.max(0, depth - 1)); // 2 spaces per level\n\n    if (depth === 1) {\n      return isLast ? \"\u2514\u2500 \" : \"\u251C\u2500 \";\n    } else {\n      return prefix + (isLast ? \"\u2514\u2500 \" : \"\u251C\u2500 \");\n    }\n  }\n}\n", "// Excel Formula Parser and Beautifier - Main Entry Point\n\nimport { ExcelFormulaParser } from \"./parser\";\nimport { ExcelRawTextFormatter } from \"./raw-text-formatter\";\nimport { FormattingOptions } from \"./types\";\n\nexport class ExcelFormulaBeautifier {\n  static rawText(formula: string, options?: Partial<FormattingOptions>): string {\n    // Parse the formula - let errors bubble up to the caller\n    const hasEquals = formula.trim().startsWith(\"=\");\n    const parsedExpression = ExcelFormulaParser.parse(formula);\n\n    // Format the parsed expression\n    const formatter = new ExcelRawTextFormatter(options);\n    return formatter.format(parsedExpression, hasEquals);\n  }\n}\n"],
  "mappings": "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",
  "names": ["excel_beautifier_form_exports", "__export", "Command", "__toCommonJS", "import_api", "import_react", "FormulaTypes", "ExcelExpression", "original", "child", "SubExpression", "FormulaExpr", "formula", "OperatorExpression", "ExcelExpression", "operator", "CellReferenceExpression", "original", "sheet", "column", "row", "isColumnAbsolute", "isRowAbsolute", "sheetPrefix", "colPrefix", "rowPrefix", "CellRangeExpression", "startCell", "endCell", "DEFAULT_FORMATTING_OPTIONS", "ExcelFormulaParser", "FormulaTypes", "acc", "value", "input", "position", "twoChar", "oneChar", "text", "parts", "startPart", "endPart", "sheet", "start", "end", "sheetSplit", "startCell", "endCell", "CellRangeExpression", "cellPattern", "match", "colAbsolute", "column", "rowAbsolute", "row", "cleanSheet", "CellReferenceExpression", "parent", "startIndex", "separator", "token", "i", "inDoubleQuote", "char", "prevChar", "operator", "upperToken", "formulaType", "cellRef", "ExcelExpression", "expression", "SubExpression", "OperatorExpression", "formula", "formulaExpr", "FormulaExpr", "braceCount", "paramExpression", "parenCount", "inSingleQuote", "trimmed", "lastChar", "cleanFormula", "baseExpression", "error", "ExcelRawTextFormatter", "options", "DEFAULT_FORMATTING_OPTIONS", "expression", "hasEqualsSign", "result", "depth", "children", "i", "child", "FormulaExpr", "SubExpression", "OperatorExpression", "CellReferenceExpression", "CellRangeExpression", "func", "params", "param", "isLast", "paramContent", "functionResult", "subResult", "totalLength", "content", "subExpr", "operator", "index", "siblings", "op", "prevSibling", "nextSibling", "shouldSpaceBefore", "shouldSpaceAfter", "prevOp", "cellRef", "cellRange", "expr", "current", "next", "prefix", "ExcelFormulaBeautifier", "formula", "options", "hasEquals", "parsedExpression", "ExcelFormulaParser", "ExcelRawTextFormatter", "import_jsx_runtime", "Command", "formula", "setFormula", "beautifiedFormula", "setBeautifiedFormula", "beautifyFormula", "inputFormula", "formulaWithEquals", "beautified", "ExcelFormulaBeautifier", "formulaError", "timeoutId", "handleFormulaChange", "value", "handleClear", "getResultPreview"]
}
